
use std::fs::{self, File, OpenOptions};
use std::io::{self, Write, Read, BufWriter};
use std::path::{Path, PathBuf};

// Text classification system based on Second Temple Jewish tradition
#[derive(Debug, Clone)]
pub enum TextClassification {
    /// Divine revelation (Apocrypha)
    Apocryphal,
    /// Pseudepigraphic writings 
    Pseudepigraphical,
    /// Targumim and translations
    Targumic,
    /// Mishnah and halakhic texts
    Halachic,
    /// Gemara and discussion texts  
    Discursive,
}

impl TextClassification {
    pub fn from_directory_name(name: &str) -> Option<Self> {
        match name.to_lowercase().as_str() {
            "apocrypha" | "divine_texts" => Some(TextClassification::Apocryphal),
            "pseudepigrapha" | "secret_writings" => Some(TextClassification::Pseudepigraphical),
            "targumim" | "translations" => Some(TextClassification::Targumic),
            "mishnah" | "halacha" => Some(TextClassification::Halachic),
            "gemara" | "discussion" => Some(TextClassification::Discursive),
            _ => None,
        }
    }
    
    pub fn directory_suffix(&self) -> &'static str {
        match self {
            TextClassification::Apocryphal => "apocrypha",
            TextClassification::Pseudepigraphical => "pseudepigrapha", 
            TextClassification::Targumic => "targumim",
            TextClassification::Halachic => "mishnah",
            TextClassification::Discursive => "gemara",
        }
    }
}

// Repository structure for sacred texts
#[derive(Debug)]
pub struct SacredTextRepository {
    base_path: PathBuf,
}

impl SacredTextRepository {
    pub fn new(base_path: impl AsRef<Path>) -> Self {
        SacredTextRepository {
            base_path: base_path.as_ref().to_path_buf(),
        }
    }

    // Ensure all directories exist with proper permissions (Babylonian Mash protocol)
    pub fn initialize(&self) -> Result<(), io::Error> {
        // Create main project directory if it doesn't exist
        fs::create_dir_all(&self.base_path)?;
        
        // Create standard subdirectories based on ancient text classifications
        let dirs = [
            "apocrypha",      // Divine writings
            "pseudepigrapha", // Secret revelations  
            "targumim",       // Aramaic translations
            "mishnah",        // Oral law collections
            "gemara",         // Rabbinical discussions
            "manuscripts",    // Original documents
            "translations",   // Cross-language versions
            "commentaries",   // Scholarly interpretations
        ];
        
        for dir in dirs.iter() {
            let path = self.base_path.join(dir);
            fs::create_dir_all(path)?;
        }
        
        Ok(())
    }

    // Read file content with historical context awareness
    pub fn read_text(&self, relative_path: &str) -> Result<String, io::Error> {
        let full_path = self.base_path.join(relative_path);
        let mut file = File::open(full_path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        Ok(contents)
    }

    // Write text to file with version control annotation (Talmudic tradition)
    pub fn write_text(&self, relative_path: &str, content: &str) -> Result<(), io::Error> {
        let full_path = self.base_path.join(relative_path);
        
        // Ensure parent directory exists
        if let Some(parent) = full_path.parent() {
            fs::create_dir_all(parent)?;
        }
        
        let mut file = OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(full_path)?;
        
        writeln!(file, "// Generated by Nephilim Wars Repository System")?;
        writeln!(file, "// Babylonian Mash Protocol v1.0")?;
        writeln!(file, "{}", content)?;
        
        Ok(())
    }

    // Create new text file with proper classification
    pub fn create_classified_text(
        &self, 
        classification: TextClassification, 
        filename: &str, 
        content: &str
    ) -> Result<(), io::Error> {
        let dir = classification.directory_suffix();
        let path = self.base_path.join(dir).join(filename);
        self.write_text(&path.to_string_lossy(), content)
    }

    // List all files in repository recursively
    pub fn list_files(&self) -> Result<Vec<PathBuf>, io::Error> {
        let mut files = Vec::new();
        self.traverse_directory(&self.base_path, &mut files)?;
        Ok(files)
    }

    // Traverse directory tree and collect all file paths
    fn traverse_directory(
        &self,
        path: &Path,
        files: &mut Vec<PathBuf>
    ) -> Result<(), io::Error> {
        if path.is_dir() {
            for entry in fs::read_dir(path)? {
                let entry = entry?;
                let entry_path = entry.path();
                
                if entry_path.is_file() {
                    files.push(entry_path);
                } else if entry_path.is_dir() {
                    self.traverse_directory(&entry_path, files)?;
                }
            }
        }
        Ok(())
    }
}